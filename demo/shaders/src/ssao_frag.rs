// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use rafx_framework::RafxResult;

#[allow(unused_imports)]
use rafx_framework::{
    DescriptorSetAllocator, DescriptorSetArc, DescriptorSetBindings, DescriptorSetInitializer,
    DescriptorSetWriter, DescriptorSetWriterContext, DynDescriptorSet, ImageViewResource,
    ResourceArc,
};

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct SsaoConfigUboStd140 {
    pub kernel: [[f32; 3]; 32], // +0 (size: 384)
    pub _padding0: [u8; 128],   // +384 (size: 128)
    pub kernel_size: u32,       // +512 (size: 4)
    pub radius_vs: f32,         // +516 (size: 4)
    pub bias: f32,              // +520 (size: 4)
    pub _padding1: [u8; 4],     // +524 (size: 4)
} // 528 bytes

impl Default for SsaoConfigUboStd140 {
    fn default() -> Self {
        SsaoConfigUboStd140 {
            kernel: [<[f32; 3]>::default(); 32],
            _padding0: [u8::default(); 128],
            kernel_size: <u32>::default(),
            radius_vs: <f32>::default(),
            bias: <f32>::default(),
            _padding1: [u8::default(); 4],
        }
    }
}

pub type SsaoConfigUboUniform = SsaoConfigUboStd140;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct PerViewDataStd140 {
    pub proj: [[f32; 4]; 4],     // +0 (size: 64)
    pub inv_proj: [[f32; 4]; 4], // +64 (size: 64)
} // 128 bytes

impl Default for PerViewDataStd140 {
    fn default() -> Self {
        PerViewDataStd140 {
            proj: <[[f32; 4]; 4]>::default(),
            inv_proj: <[[f32; 4]; 4]>::default(),
        }
    }
}

pub type PerViewDataUniform = PerViewDataStd140;

pub const DEPTH_TEXTURE_DESCRIPTOR_SET_INDEX: usize = 1;
pub const DEPTH_TEXTURE_DESCRIPTOR_BINDING_INDEX: usize = 3;
pub const NORMAL_TEXTURE_DESCRIPTOR_SET_INDEX: usize = 1;
pub const NORMAL_TEXTURE_DESCRIPTOR_BINDING_INDEX: usize = 4;
pub const PER_VIEW_DATA_DESCRIPTOR_SET_INDEX: usize = 0;
pub const PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const SSAO_CONFIG_DESCRIPTOR_SET_INDEX: usize = 1;
pub const SSAO_CONFIG_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const CLAMP_SAMPLER_DESCRIPTOR_SET_INDEX: usize = 1;
pub const CLAMP_SAMPLER_DESCRIPTOR_BINDING_INDEX: usize = 1;

pub struct DescriptorSet0Args<'a> {
    pub per_view_data: &'a PerViewDataUniform,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet0Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_buffer_data(
            PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX as u32,
            args.per_view_data,
        );
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet0Args,
    ) {
        descriptor_set.set_buffer_data(
            PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX as u32,
            args.per_view_data,
        );
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet0Args,
    ) {
        self.set_per_view_data(args.per_view_data);
    }

    pub fn set_per_view_data(
        &mut self,
        per_view_data: &PerViewDataUniform,
    ) {
        self.0
            .set_buffer_data(PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX as u32, per_view_data);
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

pub struct DescriptorSet1Args<'a> {
    pub ssao_config: &'a SsaoConfigUboUniform,
    pub depth_texture: &'a ResourceArc<ImageViewResource>,
    pub normal_texture: &'a ResourceArc<ImageViewResource>,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet1Args<'a> {
    type Output = DescriptorSet1;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet1(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet1Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_buffer_data(
            SSAO_CONFIG_DESCRIPTOR_BINDING_INDEX as u32,
            args.ssao_config,
        );
        descriptor_set.set_image(
            DEPTH_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32,
            args.depth_texture,
        );
        descriptor_set.set_image(
            NORMAL_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32,
            args.normal_texture,
        );
    }
}

pub struct DescriptorSet1(pub DynDescriptorSet);

impl DescriptorSet1 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet1Args,
    ) {
        descriptor_set.set_buffer_data(
            SSAO_CONFIG_DESCRIPTOR_BINDING_INDEX as u32,
            args.ssao_config,
        );
        descriptor_set.set_image(
            DEPTH_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32,
            args.depth_texture,
        );
        descriptor_set.set_image(
            NORMAL_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32,
            args.normal_texture,
        );
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet1Args,
    ) {
        self.set_ssao_config(args.ssao_config);
        self.set_depth_texture(args.depth_texture);
        self.set_normal_texture(args.normal_texture);
    }

    pub fn set_ssao_config(
        &mut self,
        ssao_config: &SsaoConfigUboUniform,
    ) {
        self.0
            .set_buffer_data(SSAO_CONFIG_DESCRIPTOR_BINDING_INDEX as u32, ssao_config);
    }

    pub fn set_depth_texture(
        &mut self,
        depth_texture: &ResourceArc<ImageViewResource>,
    ) {
        self.0
            .set_image(DEPTH_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32, depth_texture);
    }

    pub fn set_normal_texture(
        &mut self,
        normal_texture: &ResourceArc<ImageViewResource>,
    ) {
        self.0.set_image(
            NORMAL_TEXTURE_DESCRIPTOR_BINDING_INDEX as u32,
            normal_texture,
        );
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_ssao_config_ubo_std140() {
        assert_eq!(std::mem::size_of::<SsaoConfigUboStd140>(), 528);
        assert_eq!(std::mem::size_of::<[[f32; 3]; 32]>(), 384);
        assert_eq!(std::mem::align_of::<[[f32; 3]; 32]>(), 4);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, kernel), 0);
        assert_eq!(std::mem::size_of::<[u8; 128]>(), 128);
        assert_eq!(std::mem::align_of::<[u8; 128]>(), 1);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, _padding0), 384);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, kernel_size), 512);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, radius_vs), 516);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, bias), 520);
        assert_eq!(std::mem::size_of::<[u8; 4]>(), 4);
        assert_eq!(std::mem::align_of::<[u8; 4]>(), 1);
        assert_eq!(memoffset::offset_of!(SsaoConfigUboStd140, _padding1), 524);
    }

    #[test]
    fn test_struct_per_view_data_std140() {
        assert_eq!(std::mem::size_of::<PerViewDataStd140>(), 128);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerViewDataStd140, proj), 0);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerViewDataStd140, inv_proj), 64);
    }
}
